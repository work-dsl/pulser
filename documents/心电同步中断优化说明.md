# 心电同步触发中断优化说明

## 优化目标

减少不必要的中断开销，提高系统效率，避免在脉冲输出期间误触发。

## 优化内容

### 1. 输入捕获中断（IC中断）动态控制

**优化前**：
- IC中断始终开启，在整个心电同步过程中持续检测R波

**优化后**：
- 只在需要检测R波的阶段开启IC中断
- 在延时和脉冲输出期间关闭IC中断

### 2. 输出比较中断（OC中断）按需开启

**优化前**：
- 可能存在OC中断不必要的开启

**优化后**：
- 只在检测到R波需要延时时才启动OC中断
- 延时到达后立即关闭OC中断

## 中断状态切换流程

### 优化后的完整流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 状态：WAIT_R_TRIGGER (等待触发R波)                              │
│ IC中断：✓ 开启                                                  │
│ OC中断：✗ 关闭                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 检测到R波
┌─────────────────────────────────────────────────────────────────┐
│ 状态：WAIT_DELAY (等待延时)                                     │
│ IC中断：✗ 关闭 ← 【优化】不需要检测R波                         │
│ OC中断：✓ 开启 ← 【优化】只在需要延时时开启                    │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 延时到达
┌─────────────────────────────────────────────────────────────────┐
│ 状态：PULSING (脉冲输出中)                                      │
│ IC中断：✗ 关闭 ← 【优化】输出期间不检测R波，避免误触发         │
│ OC中断：✗ 关闭 ← 【优化】延时已完成，立即关闭                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 脉冲输出完成
┌─────────────────────────────────────────────────────────────────┐
│ 状态：STOP_TIME (停止时间)                                      │
│ IC中断：✓ 开启 ← 【优化】重新开启，需要计数R波                 │
│ OC中断：✗ 关闭                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 停止时间结束
┌─────────────────────────────────────────────────────────────────┐
│ 状态：WAIT_INTERVAL (等待R波间隔)                               │
│ IC中断：✓ 开启 ← 需要检查间隔条件                              │
│ OC中断：✗ 关闭                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 间隔条件满足，检测到新R波
                              回到 WAIT_DELAY 状态
```

## 代码修改详情

### 修改点1：检测到触发R波时关闭IC中断

**位置**：`HAL_TIM_IC_CaptureCallback()` - `SYNC_STATUS_WAIT_R_TRIGGER` 分支

```c
case SYNC_STATUS_WAIT_R_TRIGGER:
    /* 检测到触发R波，启动延时 */
    g_ecg_sync.state = SYNC_STATUS_WAIT_DELAY;
    
    /* 【新增】关闭输入捕获中断（延时和脉冲输出期间不需要检测R波） */
    (void)HAL_TIM_IC_Stop_IT(htim, TIM_CHANNEL_1);
    
    /* 设置输出比较时间点并启动OC中断 */
    uint16_t target = (uint16_t)(cap + g_ecg_sync.delay_ticks);
    __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, target);
    __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
    (void)HAL_TIM_OC_Start_IT(htim, TIM_CHANNEL_2);
    break;
```

### 修改点2：间隔满足再次触发时关闭IC中断

**位置**：`HAL_TIM_IC_CaptureCallback()` - `SYNC_STATUS_WAIT_INTERVAL` 分支

```c
case SYNC_STATUS_WAIT_INTERVAL:
    if (g_ecg_sync.r_cnt_stop >= g_ecg_sync.cfg.interval_R) {
        if (g_ecg_sync.repeats_left > 0U) {
            g_ecg_sync.repeats_left--;
            
            if (g_ecg_sync.repeats_left > 0U) {
                g_ecg_sync.state = SYNC_STATUS_WAIT_DELAY;
                
                /* 【新增】关闭输入捕获中断 */
                (void)HAL_TIM_IC_Stop_IT(htim, TIM_CHANNEL_1);
                
                /* 设置输出比较时间点并启动OC中断 */
                uint16_t target_next = (uint16_t)(cap + g_ecg_sync.delay_ticks);
                __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, target_next);
                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
                (void)HAL_TIM_OC_Start_IT(htim, TIM_CHANNEL_2);
            }
        }
    }
    break;
```

### 修改点3：脉冲输出完成进入停止时间时重启IC中断

**位置**：`HRTIM1_TIMB_IRQHandler()` - 心电同步模式完成处理

```c
if (g_control.mode == PULSE_MODE_ECG_SYNC) {
    pulse_engine_notify_output_complete();
    
    if (g_ecg_sync.state == SYNC_STATUS_PULSING) {
        /* 进入停止时间 */
        g_ecg_sync.state = SYNC_STATUS_STOP_TIME;
        g_ecg_sync.r_cnt_stop = 0U;
        
        /* 【新增】重新启动输入捕获中断（需要在停止时间内计数R波） */
        (void)HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_1);
        
        /* 配置并启动停止时间定时器 */
        config_stop_time_timer(g_ecg_sync.cfg.stop_delay_ms);
        __HAL_TIM_ENABLE(&htim6);
    }
}
```

## 优化效果

### 1. 减少中断次数

**优化前**：
- IC中断：在延时期间和脉冲输出期间仍会触发（浪费）
- 如果延时100ms，心率60次/分，约会产生6次无用的IC中断

**优化后**：
- IC中断：只在需要检测R波的阶段触发
- 延时和脉冲输出期间完全不产生IC中断

### 2. 避免误触发

**优化前风险**：
- 脉冲输出期间的高频信号可能被误检测为R波
- 可能导致状态机异常

**优化后**：
- 脉冲输出期间IC中断关闭，不会误检测
- 状态机更加稳定可靠

### 3. 降低CPU负载

**估算**（基于心率60次/分，延时100ms，3群脉冲输出50ms）：

| 阶段 | 优化前 | 优化后 | 减少 |
|------|--------|--------|------|
| 延时期间 | ~6次IC中断 | 0次 | -6 |
| 输出期间 | ~3次IC中断 | 0次 | -3 |
| 单次触发 | ~9次无用中断 | 0次 | **-9次** |

### 4. 提高实时性

- 减少中断嵌套的可能性
- 降低中断延迟（Interrupt Latency）
- 提高关键任务的响应速度

## 注意事项

### 1. OC中断始终按需开启

OC中断（输出比较中断）的处理已经是最优的：
- 只在检测到R波需要延时时启动
- 延时到达后在 `HAL_TIM_OC_DelayElapsedCallback()` 中立即关闭
- 不会产生不必要的中断

### 2. IC中断的关键时刻

IC中断（输入捕获中断）需要开启的时刻：
- ✅ WAIT_R_TRIGGER：等待触发R波
- ✅ STOP_TIME：停止时间内计数R波
- ✅ WAIT_INTERVAL：等待间隔满足，检查条件

IC中断需要关闭的时刻：
- ✅ WAIT_DELAY：延时期间（不需要检测R波）
- ✅ PULSING：脉冲输出期间（避免误触发）

### 3. 调试建议

如果需要验证优化效果，可以：

```c
// 在关键位置添加调试输出
case SYNC_STATUS_WAIT_R_TRIGGER:
    LOG_D("IC中断关闭 - 进入延时");
    (void)HAL_TIM_IC_Stop_IT(htim, TIM_CHANNEL_1);
    // ...

// 在脉冲完成时
LOG_D("IC中断重启 - 进入停止时间");
(void)HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_1);
```

或者使用GPIO翻转来观察中断开关时机：

```c
// 关闭IC中断时
gpio_write(DEBUG_PIN, 0);
(void)HAL_TIM_IC_Stop_IT(htim, TIM_CHANNEL_1);

// 开启IC中断时
(void)HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_1);
gpio_write(DEBUG_PIN, 1);
```

## 总结

通过这次优化，实现了：

1. ✅ **智能中断管理**：IC和OC中断都按需开启/关闭
2. ✅ **减少中断开销**：每次触发约减少9次无用中断
3. ✅ **避免误触发**：脉冲输出期间不检测R波
4. ✅ **提高稳定性**：状态机更加可靠
5. ✅ **降低功耗**：减少CPU唤醒次数

这种中断管理策略是嵌入式系统优化的最佳实践，既保证了功能的正确性，又提高了系统效率。

