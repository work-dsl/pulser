# 项目架构说明文档

## 概述

本项目采用分层架构设计，遵循**高内聚、低耦合**的软件设计原则，各层职责明确，依赖关系清晰。

## 架构分层

```
┌─────────────────────────────────────────────────────────────────┐
│                        users/ (用户层)                           │
│                    main.c - 程序入口                             │
│                    配置文件(*.h)                                 │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    applications/ (应用层)                        │
│  custom_slave.c/h  - 从机协议处理（握手、地址过滤、系统命令）    │
│  custom_host.c/h   - 主机协议处理                                │
│  major_logic.c/h   - 主逻辑协调器（模块协调、事件处理）           │
│  cmd_handler.c/h   - 命令处理服务（业务命令分发和处理）          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                     modules/ (业务模块层)                        │
│  pulse_engine.c/h  - 脉冲引擎（核心业务）                        │
│  data_mgmt.c/h     - 数据管理（版本号、序列号管理）              │
│  safety.c/h        - 安全模块（过流保护、看门狗、复位）           │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  middlewares/ (中间件层)                         │
│  proto/           - 通用协议框架                                 │
│    proto.c/h         - 协议解析器基础框架                        │
│    proto_custom.c/h  - 自定义协议实现                           │
│  RTT/             - SEGGER RTT调试工具                          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   utilities/ (工具层)                            │
│  kfifo, log, crc, stimer 等通用工具                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   devices/ (设备层)                              │
│  serial, gpio, led, key, watchdog 等设备驱动封装                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   drivers/bsp/ (驱动层)                          │
│  bsp_gpio, bsp_usart, bsp_hrtim 等硬件抽象层                    │
└─────────────────────────────────────────────────────────────────┘
```

## 各层职责详解

### 1. drivers/bsp/ - 驱动层（最底层）
**职责**：
- 硬件寄存器操作的直接封装
- 提供硬件抽象接口
- 与MCU硬件紧密相关

**特点**：
- 不依赖其他任何层
- 只能被设备层调用

### 2. devices/ - 设备层
**职责**：
- 基于BSP层实现设备驱动
- 提供设备操作接口（如 serial_open, gpio_read）
- 设备状态管理

**特点**：
- 依赖：drivers/bsp, utilities
- 提供统一的设备操作接口

### 3. utilities/ - 工具层
**职责**：
- 提供通用的算法和数据结构
- 日志、CRC、FIFO、定时器等工具函数

**特点**：
- 不依赖业务逻辑
- 可被任何上层调用

### 4. middlewares/ - 中间件层
**职责**：
- 提供通用的服务框架
- 协议解析框架（proto）
- 调试工具（RTT）

**特点**：
- 依赖：devices, utilities
- 提供可复用的服务框架

**重要文件**：
- `proto/proto.c/h` - 通用协议解析框架
- `proto/proto_custom.c/h` - 自定义协议实现（从modules移到这里）

### 5. modules/ - 业务模块层
**职责**：
- 实现核心业务逻辑
- 各模块相互独立，通过回调机制交互

**特点**：
- 依赖：middlewares, devices, utilities
- **不能直接依赖应用层**
- **模块间通过回调机制解耦**

**模块说明**：

#### pulse_engine（脉冲引擎）
- 职责：脉冲序列生成和控制
- 提供：参数配置、启动/停止、状态查询
- 不依赖其他业务模块

#### data_mgmt（数据管理）
- 职责：版本号、序列号等数据的存储和管理
- 使用Flash进行持久化存储
- 不依赖其他业务模块

#### safety（安全模块）
- 职责：过流保护、看门狗、系统复位
- 通过**回调机制**通知上层过流事件
- **不直接调用pulse_engine**，解耦设计

### 6. applications/ - 应用层
**职责**：
- 协议应用处理（握手、地址过滤）
- 系统控制命令处理（复位、自检等）
- 业务命令分发和处理
- 主逻辑协调

**特点**：
- 依赖：modules, middlewares
- 提供完整的应用功能

**重要文件**：

#### cmd_handler.c/h（命令处理服务）
- 职责：
  - 接收协议层传来的业务命令
  - 调用业务模块接口
  - 构建响应数据返回协议层
- 特点：
  - 分离命令处理和协议处理
  - 统一的命令分发机制

#### custom_slave.c/h（从机协议处理）
- 职责：
  - 初始化协议解析器
  - 设备地址过滤
  - 握手流程处理
  - 系统控制命令处理（复位、自检等）
  - **将业务命令转发给cmd_handler**
- 特点：
  - 只负责协议层面的处理
  - 业务逻辑由cmd_handler处理

#### custom_host.c/h（主机协议处理）
- 职责：
  - 发送命令并等待响应
  - 超时重试管理
  - 从机管理

#### major_logic.c/h（主逻辑协调器）
- 职责：
  - **协调各模块初始化**
  - **处理模块间事件**（如脉冲完成、过流事件）
  - **系统级状态管理**（如复位请求）
- 特点：
  - 整合各模块工作流程
  - 通过回调机制接收模块事件

### 7. users/ - 用户层（顶层）
**职责**：
- 程序入口（main.c）
- 系统配置文件

**特点**：
- 调用应用层接口
- 负责初始化流程和主循环

## 依赖关系图

```
        ┌─────────┐
        │  main   │
        └────┬────┘
             │
        ┌────▼────────────────┐
        │   applications      │
        │  (custom_slave,     │
        │   major_logic,      │
        │   cmd_handler)      │
        └────┬────────────────┘
             │
        ┌────▼──────────────────┐
        │      modules          │
        │ (pulse_engine, data,  │
        │      safety)          │
        └────┬──────────────────┘
             │
    ┌────────┴────────┐
    │                 │
┌───▼────┐    ┌──────▼──────┐
│devices │    │ middlewares │
│        │    │   (proto)   │
└───┬────┘    └──────┬──────┘
    │                │
    └────────┬───────┘
             │
        ┌────▼──────┐
        │ utilities │
        └────┬──────┘
             │
        ┌────▼────┐
        │drivers/ │
        │  bsp    │
        └─────────┘
```

## 解耦设计

### 1. 模块间回调机制

**问题**：原先 `safety.c` 直接调用 `pulse_engine_stop()`，造成模块间耦合。

**解决方案**：
```c
// safety.h - 定义回调类型
typedef void (*ocp_event_cb_t)(void);
void safety_set_ocp_callback(ocp_event_cb_t callback);

// major_logic.c - 注册回调
static void on_ocp_event_handler(void) {
    pulse_engine_stop();
}

void major_logic_init(void) {
    safety_set_ocp_callback(on_ocp_event_handler);
}
```

### 2. 命令处理分离

**问题**：原先 `custom_slave.c` 包含大量业务逻辑处理函数。

**解决方案**：
- 在应用层创建 `cmd_handler` 专门处理业务命令
- `custom_slave` 只负责协议层面的处理
- 通过回调机制将响应返回给协议层

```c
// custom_slave.c
cmd_handler_set_response_callback(slave_cmd_response_callback);

// 协议层收到命令后
cmd_handler_process(cmd, payload, len);

// cmd_handler处理完成后回调
static void slave_cmd_response_callback(uint8_t cmd, const cmd_result_t *result) {
    // 构建并发送响应帧
}
```

### 3. 主逻辑协调

**问题**：各模块初始化和事件处理分散。

**解决方案**：
- 创建 `major_logic` 作为应用主逻辑协调器
- 统一管理模块初始化顺序
- 集中处理模块间的事件协调

## 数据流

### 命令接收处理流程

```
主机发送命令
    ↓
[serial设备层] 数据进入FIFO
    ↓
[middlewares/proto] 协议解析
    ↓
[applications/custom_slave] 帧接收回调
    ↓
地址过滤 & 握手检查
    ↓
系统命令? ─┬─ YES → 本地处理（复位、自检等）
           │
           └─ NO → 转发给 applications/cmd_handler
                       ↓
                   调用业务模块接口
                   (pulse_engine, data_mgmt)
                       ↓
                   构建响应数据
                       ↓
                   通过回调返回 custom_slave
                       ↓
                   构建协议帧并发送
```

### 事件通知流程

```
[safety模块] 检测到过流
    ↓
触发中断 → OCP_handle()
    ↓
调用注册的回调 g_ocp_callback()
    ↓
[major_logic] on_ocp_event_handler()
    ↓
调用 pulse_engine_stop()
    ↓
上报事件给上位机
```

## 初始化顺序

```c
int main(void) {
    // 1. 底层驱动初始化
    board_init();           // BSP初始化
    
    // 2. 系统服务初始化
    stimer_init();          // 软件定时器
    
    // 3. 安全模块初始化
    safety_init();          // LED、看门狗、过流保护
    
    // 4. 主逻辑协调器初始化（会初始化所有业务模块）
    major_logic_init();     // → data_mgmt_init()
                           // → pulse_engine_init()
                           // → 设置模块间回调
    
    // 5. 协议应用层初始化
    slave_proto_init();     // → cmd_handler_init()
                           // → proto_init()
    
    // 6. 主循环
    while(1) {
        stimer_service();       // 定时器服务
        slave_proto_task();     // 协议处理
        major_logic_task();     // 主逻辑协调
    }
}
```

## 文件组织

### 移动的文件
- `modules/custom_proto.*` → `middlewares/proto/custom_proto.*`

### 新增的文件
- `applications/cmd_handler.c/h` - 命令处理服务
- `applications/major_logic.c/h` - 主逻辑协调器

### 修改的文件
- `applications/custom_slave.c` - 简化为纯协议处理
- `modules/safety.c/h` - 添加回调机制
- `users/main.c` - 更新初始化流程

## 设计原则体现

### 1. 高内聚
- 每个模块职责单一明确
- 相关功能集中在同一模块

### 2. 低耦合
- 模块间通过接口调用
- 使用回调机制解耦
- 依赖方向单向向下

### 3. 分层清晰
- 严格的分层结构
- 上层可调用下层，下层不依赖上层
- 同层模块通过回调通信

### 4. 易于测试
- 模块独立性强
- 可以单独测试每个模块
- 便于模拟和替换

### 5. 易于扩展
- 添加新命令只需修改 cmd_handler
- 添加新模块无需改动现有代码
- 通过回调机制灵活扩展

## 总结

经过重构后的架构具有以下优势：

1. **职责明确**：每个文件和模块的职责清晰
2. **低耦合**：模块间通过回调和接口通信，避免直接依赖
3. **高内聚**：相关功能集中，便于维护
4. **易扩展**：新增功能无需大范围修改
5. **易测试**：模块独立，便于单元测试
6. **可维护**：结构清晰，便于理解和维护

这种架构设计符合软件工程的最佳实践，为项目的长期维护和扩展奠定了良好的基础。

